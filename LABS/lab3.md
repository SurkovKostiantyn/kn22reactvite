# Lab 3: Реалізація пошуку та фільтрації

## 1. Логіка роботи пошуку

Для реалізації пошуку ми використовуємо керований компонент `SearchBar`, стан якого зберігається у батьківському компоненті `App`.

**src/components/moleculas/SearchBar.jsx**

```jsx
// Імпорт компонента Input
import Input from '../atoms/Input';

function SearchBar(props) {
  const { searchTerm, onSearchChange } = props;
  return (
    <div>
      <Input
        type="text"
        placeholder="Пошук постів..."
        value={searchTerm}
        onChange={(e) => onSearchChange(e.target.value)}
        id="search"
        name="search"
      />
    </div>
  );
}

export default SearchBar;
```

**src/App.jsx (фрагмент з підняттям стану)**

```jsx
function App() {
  // Стан для пошукового запиту
  const [searchTerm, setSearchTerm] = useState('');

  // ...

  return (
    // ...
    // Передача стану та функції його оновлення через пропси
    <SearchBar searchTerm={searchTerm} onSearchChange={setSearchTerm} />
    // ...
  );
}
```

## 2. Логіка фільтрації

Фільтрація виконується шляхом створення нового масиву `filteredPosts` на основі `searchTerm` та `activeCategory`. Ми не змінюємо оригінальний масив `mockPosts`.

**src/App.jsx (фрагмент з логікою фільтрації)**

```jsx
// Логіка фільтрації
const filteredPosts = mockPosts.filter((post) => {
  // Перевірка на відповідність пошуковому запиту (за контентом або автором)
  // Використовуємо .toLowerCase() для регістронезалежного пошуку
  const matchesSearch =
    post.content.toLowerCase().includes(searchTerm.toLowerCase()) ||
    post.author.toLowerCase().includes(searchTerm.toLowerCase());

  // Перевірка на відповідність категорії
  const matchesCategory =
    activeCategory === 'All' || post.category === activeCategory;

  // Повертаємо true, тільки якщо обидві умови виконуються
  return matchesSearch && matchesCategory;
});
```

## 3. Обробка "порожнього результату"

Для відображення повідомлення, коли нічого не знайдено, ми використовуємо тернарний оператор (або умовний рендеринг). Якщо довжина відфільтрованого масиву `filteredPosts` більше 0, ми рендеримо список знайдених постів. В іншому випадку — компонент з повідомленням про відсутність результатів.

**src/App.jsx (фрагмент рендерингу)**

```jsx
<div>
  {filteredPosts.length > 0 ? (
    // Рендеримо пости
    filteredPosts.map((post) => <Post key={post.id} {...post} />)
  ) : (
    // Рендеримо повідомлення про порожній результат
    <Paragraph text="Нічого не знайдено за вашим запитом." />
  )}
</div>
```

---

## 4. Відповіді на контрольні запитання

### 1. Що таке "підняття стану" (lifting state up) і чому ми використовуємо його для `SearchBar`?

"Підняття стану" — це патерн в React, при якому стан, необхідний кільком компонентам, переміщується до їхнього найближчого спільного предка.
У нашому випадку, стан пошуку (`searchTerm`) потрібен не тільки самому компоненту `SearchBar` (для відображення введеного тексту), але й батьківському компоненту `App` (для фільтрації списку постів). Якщо б ми зберігали стан тільки всередині `SearchBar`, компонент `App` не знав би, що користувач ввів, і не зміг би відфільтрувати дані. Тому ми "підняли" стан в `App` і передали його назад в `SearchBar` через пропси.

### 2. Поясніть асинхронну природу оновлення стану в `useState`.

Функція оновлення стану (`setState`) в React працює асинхронно. Це означає, що React не оновлює змінну стану одразу після виклику функції. Натомість він "планує" це оновлення.
React може об'єднувати декілька оновлень стану (batching) в один ререндер для покращення продуктивності. Тому, якщо ви спробуєте прочитати значення стану (`console.log(state)`) відразу після виклику `setState(newState)`, ви побачите ще **старе** значення. Нове значення буде доступне лише під час наступного рендеру компонента.

### 3. Чому для фільтрації ми створюємо нову змінну `filteredPosts`, а не змінюємо оригінальний масив `postsData` у стані?

Це важливо для збереження оригінальних даних (concept of immutability).
Якщо ми змінимо (мутуємо) оригінальний масив `postsData`, відфільтрувавши його на місці, ми безповоротно втратимо ті елементи, що не пройшли фільтр. Коли користувач очистить поле пошуку або змінить категорію, ми не зможемо повернути повний список, оскільки вихідні дані вже були видалені з пам'яті.
Створення похідного масиву (`filteredPosts`) дозволяє нам завжди мати "джерело істини" (оригінальні `postsData`) і динамічно відображати лише потрібну підмножину даних на основі поточного стану фільтрів.

### 4. У чому перевага використання керованих компонентів над некерованими при реалізації пошуку?

Переваги керованих компонентів (де значення input контролюється через state React):

- **Миттєвий зворотний зв'язок (Instant Feedback)**: Ми маємо доступ до значення при кожному натисканні клавіші (`onChange`). Це дозволяє реалізувати "живий" пошук (оновлення результатів одразу при введенні), валідацію вводу або форматування "на льоту".
- **Single Source of Truth**: Значення в полі вводу завжди синхронізоване зі станом React. Ми точно знаємо, що бачить користувач і що має програма.
- **Декларативність**: Логіка роботи компонента стає більш явною і передбачуваною.
  У некерованих компонентах (через `ref`) ми б змушені були вручну звертатися до DOM елемента, щоб отримати його значення (імперативний підхід), що ускладнює реалізацію миттєвого пошуку.
