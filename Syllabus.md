# План вивчення предмету

## Лекції(36 годин)

### Модуль 1. Основи декларативного програмування та екосистема розробки

#### Лекція №1. Еволюція веб-технологій та місце React у сучасній розробці.

Перша лекція присвячена аналізу переходу від статичного HTML до динамічних веб-інтерфейсів. Розглядається концепція Single Page Application (SPA) та порівняння імперативного підходу (DOM API) з декларативним, який пропонує React. Важливим аспектом є розуміння того, що React не є фреймворком у класичному розумінні, а бібліотекою, яка фокусується на рівні представлення (View). Обговорюється історія створення бібліотеки компанією Facebook та її вплив на індустрію через впровадження компонентно-орієнтованої архітектури.

#### Лекція №2. Механізми роботи React: Virtual DOM та Reconciliation.

Детальне вивчення алгоритмів, що забезпечують високу продуктивність React. Розглядається структура Virtual DOM як абстракції над реальним DOM-деревом. Аналізується алгоритм Reconciliation, який дозволяє React мінімізувати кількість операцій з реальним DOM шляхом обчислення різниці (diffing) між станами. Це критично для розуміння того, як React досягає ефективного оновлення інтерфейсу при зміні великих масивів даних.

#### Лекція №3. Середовище розробки та сучасний інструментарій (Tooling).

Аналіз екосистеми Node.js, менеджерів пакетів (npm, yarn, pnpm) та систем збірки. Особлива увага приділяється Vite як сучасному стандарту, що замінив Create React App, завдяки використанню Native ESM та швидкій гарячій заміні модулів (HMR). Студенти вивчають роль Babel у трансляції сучасного JavaScript (ES6+) та SWC як високопродуктивної альтернативи.

#### Лекція №4. JSX: Синтаксис, обмеження та можливості.

Вивчення JavaScript XML (JSX) як синтаксичного розширення, що дозволяє описувати структуру інтерфейсу всередині JavaScript-коду. Розглядається процес перетворення JSX у виклики React.createElement, правила вкладеності, використання виразів у фігурних дужках та відмінності між атрибутами HTML та пропсами JSX (наприклад, className замість class).

### Модуль 2. Компонентна модель та керування станом

#### Лекція №5. Функціональні компоненти та пропси (Props).

Перехід від класових компонентів до функціональних як сучасного стандарту розробки. Розглядається концепція "чистих функцій" у контексті компонентів. Вивчення механізму передачі даних через пропси, їх незмінності (read-only) та односпрямованого потоку даних (one-way data flow), що є ключовим для передбачуваності стану додатка.

#### Лекція №6. Хук useState: Робота з локальним станом.

Введення в систему хуків React. Детальне вивчення useState: синтаксис, ініціалізація та асинхронна природа оновлення стану. Обговорюється проблема пакетного оновлення (batching) та правила використання хуків (Rules of Hooks), такі як виклик тільки на верхньому рівні функцій.

#### Лекція №7. Обробка подій та робота з формами.

Вивчення системи синтетичних подій (Synthetic Events), які забезпечують кросбраузерну сумісність. Порівняння керованих (controlled) та некерованих (uncontrolled) компонентів форм. Розглядається використання useRef для доступу до DOM-елементів у специфічних сценаріях, таких як інтеграція зі сторонніми бібліотеками.

#### Лекція №8. Життєвий цикл та хук useEffect.

Аналіз етапів життєвого циклу компонента: монтування, оновлення та розмонтування. Вивчення хука useEffect як універсального інструменту для роботи з побічними ефектами (side effects), такими як мережеві запити, підписки або маніпуляції з таймерами. Розглядається масив залежностей та функція очищення (cleanup function) для запобігання витоку пам’яті.

#### Лекція №9. Списки, ключі та умовний рендеринг.

Методи ітерації по масивах даних для генерації списків компонентів. Важливість атрибута key для алгоритму дифінгу React та наслідки використання індексів масиву як ключів. Розглядаються патерни умовного рендерингу за допомогою логічних операторів (&&) та тернарних операторів для створення гнучких інтерфейсів.

### Модуль 3. Просунуті концепції та архітектурні патерни

#### Лекція №10. Оптимізація продуктивності: useMemo та useCallback.

Вивчення механізмів мемоїзації для запобігання зайвим обчисленням та рендерингам. Аналіз випадків, коли використання цих хуків є виправданим, а коли — надлишковим. Розглядається React.memo як засіб поверхневого порівняння пропсів для компонентів.

#### Лекція №11. Глобальне керування станом: Context API.

Вирішення проблеми "prop drilling" (прокидання пропсів через багато рівнів). Створення контексту, використання Provider та хука useContext. Обговорюються обмеження контексту в контексті частого оновлення даних та сценарії, коли варто використовувати зовнішні бібліотеки керування станом, такі як Redux або Zustand.

#### Лекція №12. Маршрутизація у SPA: React Router.

Концепція клієнтської маршрутизації. Налаштування BrowserRouter, Routes та Route. Вивчення динамічних параметрів шляху (useParams), вкладених маршрутів (nested routes) та програмної навігації (useNavigate).

#### Лекція №13. Взаємодія з API та асинхронність.

Методи отримання даних з сервера за допомогою fetch та axios. Обробка станів завантаження (loading) та помилок (error). Патерни інтеграції API запитів у хук useEffect та створення кастомних хуків для фетчингу даних.

#### Лекція №14. TypeScript у React: Типізація для надійності.

Впровадження TypeScript у розробку React-додатків. Типізація пропсів, станів, подій та рефів. Переваги статичної типізації для великих команд та проєктів, що корелює з вимогами до якості ПЗ у комп’ютерних науках.

### Модуль 4. Сучасна екосистема та професійні стандарти

#### Лекція №15. Тестування React-додатків.

Важливість тестування для забезпечення стабільності систем. Вивчення Jest та React Testing Library для тестування компонентів з точки зору користувача. Огляд інструментів для наскрізного тестування (Playwright, Cypress) та їх роль у CI/CD процесах.

#### Лекція №16. Стилізація та дизайн-системи.

Огляд підходів до стилізації: CSS Modules, CSS-in-JS (Styled Components) та Utility-first CSS (Tailwind CSS). Розглядається роль бібліотек компонентів, таких як Material UI або Ant Design, у прискоренні розробки корпоративних систем.

#### Лекція №17. Next.js та Server-Side Rendering (SSR).

Огляд фреймворку Next.js як розширення можливостей React. Порівняння стратегій рендерингу: Static Site Generation (SSG), Server-Side Rendering (SSR) та Incremental Static Regeneration (ISR). Вивчення концепції React Server Components (RSC) як майбутнього веб-розробки.

#### Лекція №18. Деплоймент, безпека та етика розробки.

Процес розгортання додатків на платформах Vercel, Netlify або AWS. Розглядаються питання безпеки (XSS, CSRF) та етичні аспекти використання ШІ (GitHub Copilot, ChatGPT) у процесі написання коду, що є актуальним згідно з опитуваннями 2024 року.

## Практичні заняття (18 годин)

Спрямовані на відпрацювання конкретних алгоритмічних та архітектурних задач у форматі коротких вправ та обговорень.

#### Практичне заняття №1. Налаштування оточення та робота з Git.

На практиці студенти ініціалізують проєкти, налаштовують ESLint та Prettier, а також відпрацьовують флоу роботи з гілками в Git.

#### Практичне заняття №2. Трансформація масивів даних.

Відпрацювання методів map, filter та reduce для підготовки даних до відображення в React-компонентах.

#### Практичне заняття №3. Логіка умовного відображення.

Створення складних інтерфейсів, що змінюються залежно від стану (наприклад, багаторівневі меню або таби).

#### Практичне заняття №4. Валідація введених даних.

Реалізація кастомної логіки валідації для форм без використання зовнішніх бібліотек для глибокого розуміння процесів.

#### Практичне заняття №5. Побудова ієрархії компонентів.

Практична задача з декомпозиції складного макета на дрібні, перевикористовувані модулі.

#### Практичне заняття №6. Налагодження коду (Debugging).

Використання React DevTools та точок зупинки (breakpoints) у браузері для пошуку помилок у стані та пропсах.

#### Практичне заняття №7. Робота з URL-параметрами.

Створення динамічних посилань та обробка фільтрів пошуку через Query String.

#### Практичне заняття №8. Абстракція бізнес-логіки.

Створення кастомних хуків для повторного використання логіки (наприклад, хук для визначення розміру вікна або стану онлайн/офлайн).

#### Практичне заняття №9. Аналіз продуктивності.

Використання панелі Profiler у React DevTools для ідентифікації "важких" компонентів та їх оптимізації.

## Лабораторні роботи (18 годин)

#### Лабораторна робота №1. Створення каркаса додатка та базових UI-компонентів.

Використання атомарного дизайну для створення кнопок, інпутів та карток.

#### Лабораторна робота №2. Реалізація стрічки новин або списку об'єктів.

Робота з реальними даними, впровадження списків та ключів. 
Мета: Реалізувати компонент "Стрічка новин" (News Feed) або "Список товарів", використовуючи масив об'єктів (JSON). Навчитися використовувати метод map() для генерації інтерфейсу та зрозуміти важливість пропа key для алгоритму Reconciliation.

#### Лабораторна робота №3. Інтеграція системи фільтрації та пошуку.

Робота з локальним станом для забезпечення миттєвого відгуку інтерфейсу на дії користувача.

#### Лабораторна робота №4. Розробка багатосторінкової навігації.

Впровадження React Router та створення сторінок профілю та налаштувань.

#### Лабораторна робота №5. Створення системи автентифікації.

Реалізація форм входу/реєстрації та захищених маршрутів (Protected Routes) за допомогою Context API.

#### Лабораторна робота №6. Підключення до зовнішнього API.

Використання JSONPlaceholder або власного бекенду для синхронізації даних додатку.

#### Лабораторна робота №7. Впровадження TypeScript. Повний рефакторинг коду лабораторних робіт з додаванням типізації для підвищення надійності системи.

#### Лабораторна робота №8. Написання тестів.

Покриття основних функцій додатку (наприклад, додавання коментаря або зміна профілю) юніт-тестами.

#### Лабораторна робота №9. Фінальна збірка та деплоймент.

Оптимізація бандлу та розміщення проєкту в мережі Інтернет з налаштуванням CI/CD пайплайну.

## Самостійна робота та індивідуальні дослідження

#### Дослідження екосистеми Next.js (10 годин). Самостійне вивчення App Router, Server Actions та методів оптимізації зображень.

#### Опанування інструментів тестування (8 годин). Глибоке занурення в інтеграційне тестування та мокінг API за допомогою MSW (Mock Service Worker).

#### Вивчення State Management бібліотек (8 годин). Порівняльний аналіз Redux Toolkit та Zustand. Реалізація невеликого модуля з використанням однієї з бібліотек.

#### Розробка власного кастомного хука для складних задач (6 годин). Наприклад, хук для роботи з WebSockets або IndexedDB.

#### Підготовка до захисту проєкту (16 годин). Написання документації, підготовка презентації та проведення фінального тестування розробленого додатка.
